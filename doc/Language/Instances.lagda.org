#+Title: Instances of language types
#+Author: Mark Armstrong
#+Description: Languages for us use a generic â€œsequenceâ€ interface.
#+Description: This file contains implementations includings lists and streams.
#+Startup: noindent

#+begin_src agda2
module Language.Instances where

open import Size using (Size ; â†‘_ ; âˆ ; _âŠ”Ë¢_)
open import Data.Empty using (âŠ¥ ; âŠ¥-elim)
open import Data.Unit using (tt)
open import Data.Bool using (true ; false)
open import Data.Product using (Î£-syntax ; _,_)
open import Data.Maybe using (nothing ; just)
open import Data.Maybe.Relation.Unary.Any using (just)
open import Relation.Nullary using (_because_ ; ofÊ¸ ; ofâ¿)
open import Relation.Binary.PropositionalEquality using (_â‰¡_ ; refl ; _â‰¢_)

-- Thesis imports
open import Language
#+end_src

* Lists

To represent finite strings, we may use either lists or vectors.
We begin with lists, which are a little simpler, as here vectors
will have to be packaged with their length parameters.
#+begin_src agda2
module List where
  open import Data.List using (List ; [] ; _âˆ·_)

  nonempty-head : {Î£ : Set} â†’ (xs : List Î£) â†’ (xs â‰¢ []) â†’ Î£
  nonempty-head [] []â‰¢[] = âŠ¥-elim ([]â‰¢[] refl)
  nonempty-head (x âˆ· _) _ = x
  
  nonempty-tail : {Î£ : Set} â†’ (xs : List Î£) â†’ (xs â‰¢ []) â†’ List Î£
  nonempty-tail [] []â‰¢[] = âŠ¥-elim ([]â‰¢[] refl)
  nonempty-tail (_ âˆ· xs) _ = xs
  
  FiniteString : (Î£ : Set) â†’ String Î£
  FiniteString Î£ = 
    record
      { Carrier = List Î£
      ; Îµ = just []
      ; Empty = _â‰¡ []
      ; Empty-is-Îµ = Î» xâ‰¡[] â†’ just tt , xâ‰¡[]
      ; Empty? = Î» { [] â†’ true because ofÊ¸ refl
                   ; (_ âˆ· _) â†’ false because ofâ¿ Î» () }
      ; prepend = _âˆ·_
      ; hd = nonempty-head
      ; tl = nonempty-tail
      ; prepend-nonempty = Î» ()
      ; hd-prepend = Î» c s â†’ refl
      ; tl-prepend = Î» c s â†’ refl
      ; prepend-hd-tl = Î» { [] []â‰¢[] â†’ âŠ¥-elim ([]â‰¢[] refl)
                          ; (x âˆ· s) _ â†’ refl }
      }
#+end_src
Development note: The proofs
of ~prepend-nonempty~, ~hd-prepend~ and ~tl-prepend~ were
all completable by auto.
The proof of ~prepend-hd-tl~ only required a bit of pattern matching.

* TODO Vectors

* Streams

#+begin_src agda2
module Stream where
  open import Codata.Thunk using (force)
  open import Codata.Stream using (Stream ; _âˆ·_)
  
  InfiniteString : (Î£ : Set) â†’ String Î£
  InfiniteString Î£ =
    record
        { Carrier = Î£[ i âˆˆ Size ] Stream Î£ i
        ; Îµ = nothing
        ; Empty = Î» _ â†’ âŠ¥
        ; Empty-is-Îµ = Î» { () }
        ; Empty? = Î» s â†’ false because ofâ¿ Î» x â†’ x
        ; prepend = Î» { x (i , ys) â†’ (â†‘ i) , (x âˆ· Î» where .force â†’ ys) }
        ; hd = Î» { (_ , x âˆ· _) _ â†’ x }
        ; tl = Î» { (i , _ âˆ· xs) _ â†’  {!!} , {!!} .force }
        ; prepend-nonempty = {!!}
        ; hd-prepend = {!!}
        ; tl-prepend = {!!}
        ; prepend-hd-tl = {!!}
        }
#+end_src

* COMMENT Rough work

# Copied over from ../Language.lagda.org initially.

, we will represent finite strings over an alphabet ~Î£~ in Agda
using vectors (lists with the length denoted in their type) over ~Î£~.
Infinite strings we similarly represent using (co-inductively defined) streams,
and potentially infinite strings using colists.
For example,
#+begin_example agda2
-- Bits can be ğŸ˜ or ğŸ™.
data Bit : Set where
  ğŸ˜ ğŸ™ : Bit

-- A finite sequence of bits of specified length 3.
xs : Vec Bit 3
xs = ğŸ˜ âˆ· ğŸ˜ âˆ· ğŸ˜ âˆ· []

-- An infinite sequence of bits (all ğŸ˜.)
ys : {Î¹ : Size} â†’ Stream Bit Î¹
ys = ğŸ˜ âˆ· Î» where .force â†’ ys
#+end_example
